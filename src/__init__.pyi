from typing import (
    Any,
    Generic,
    Iterator,
    Literal,
    Mapping,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    overload,
)

VT = TypeVar("VT")
DT = TypeVar("DT")

class JudyIntObjectMap(Mapping[int, VT], Sequence[int], Generic[VT]):
    def __sizeof__(self) -> int: ...
    def __value_sizeof__(self) -> int: ...
    def __len__(self) -> int: ...
    @overload
    def __contains__(self, key: int) -> bool: ...
    @overload
    def __contains__(self, key: Any) -> Literal[False]: ...
    def __getitem__(self, key: int) -> VT: ...
    def __setitem__(self, key: int, value: VT) -> None: ...
    @overload
    def get(self, key: int) -> Optional[VT]: ...
    @overload  # noqa: F811
    def get(self, key: int, default: DT = ...) -> Union[DT, VT]: ...
    @overload
    def pop(self, key: int) -> VT: ...
    @overload  # noqa: F811
    def pop(self, key: int, default: DT = ...) -> Union[DT, VT]: ...
    def clear(self) -> None: ...
    def __iter__(self) -> Iterator[int]: ...
    def keys(self) -> Iterator[int]: ...
    def values(self) -> Iterator[VT]: ...
    def items(self) -> Iterator[Tuple[int, VT]]: ...
    def by_index(self, index: int) -> int: ...

class JudyIntSet(Sequence[int]):
    def __len__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    @overload
    def __contains__(self, key: int) -> bool: ...
    @overload
    def __contains__(self, key: Any) -> Literal[False]: ...
    def __iter__(self) -> Iterator[int]: ...
    def __getitem__(self, index: int) -> int: ...
    def add(self, key: int) -> None: ...
    def remove(self, key: int) -> None: ...
